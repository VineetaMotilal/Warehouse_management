/*
. *
. * Team Id: <eYRC-2072>
. * Author List: <Veni Gupta, Vineeta Motilal, Meghna Dubey>
. * 
. * Filename: <wm_eYRC_2072>
. * Theme: <Warehouse Management-- Specific to eYRC>
. * Functions: <void buzzer_pin_config (void), void lcd_port_config (void), void color_sensor_pin_config(void),
           		void led_pin_config(void), void color_sensor_pin_interrupt_init(void), ISR(INT0_vect), 
				void filter_red(void), void filter_green(void), void filter_blue(void), void filter_clear(void), 
				void color_sensor_scaling(),void red_led(),void blue_led(),void green_led(),void black_led(),
				void adc_pin_config (void), void adc_init(),unsigned char ADC_Conversion(unsigned char Ch), 
				void print_sensor(char row, char coloumn,unsigned char channel), void velocity (unsigned char left_motor, 
				unsigned char right_motor), void servo1_pin_config (void), void servo2_pin_config (void),
				void servo3_pin_config (void), void timer1_init(void), void timer5_init(),void servo_1(unsigned char degrees),
				void servo_2(unsigned char degrees), void servo_3(unsigned char degrees), void servo_1_free (void), 
				void servo_2_free (void), void servo_3_free (void), void motion_pin_config (void), 
				void left_encoder_pin_config (void), void right_encoder_pin_config (void), void port_init(),
				void left_position_encoder_interrupt_init (void), void right_position_encoder_interrupt_init (void), 
			    void motion_set (unsigned char Direction), void forward (void), void back (void), void left (void), 
				void right (void), void soft_left (void),  void soft_right (void),  void soft_left_2 (void), 
			    void soft_right_2 (void), void stop (void), void angle_rotate(unsigned int Degrees), 
				void linear_distance_mm(unsigned int DistanceInMM), void forward_mm(unsigned int DistanceInMM), 
				void back_mm(unsigned int DistanceInMM), void left_degrees(unsigned int Degrees), 
				void right_degrees(unsigned int Degrees), void soft_left_degrees(unsigned int Degrees), 
				void soft_right_degrees(unsigned int Degrees), void soft_left_2_degrees(unsigned int Degrees), 
				void soft_right_2_degrees(unsigned int Degrees), void buzzer_on (void), void buzzer_off (void), 
			    void red_read(void), void green_read(void), void blue_read(void), void pickup(),void deposit(),
				void no_pickup(),void color_sensor(),void init_devices (void), int main()
>
. * Global Variables: <unsigned char ADC_Conversion(unsigned char);
						unsigned char ADC_Value;
						unsigned char flag = 0;
						unsigned char Left_white_line = 0;
						unsigned char Center_white_line = 0;
						unsigned char Right_white_line = 0;
						unsigned long int ShaftCountLeft = 0;  
						unsigned long int ShaftCountRight = 0; 
						unsigned int Degrees;
						volatile unsigned long int pulse = 0; 
						volatile unsigned long int red;       
						volatile unsigned long int blue;      
						volatile unsigned long int green;     
					    int red_count=0, blue_count=0, green_count=0 */




#include <avr/io.h>
#include <avr/interrupt.h>
#include <util/delay.h>
#include <math.h> 
#include "lcd.c"
void port_init();
void timer5_init();
void velocity(unsigned char, unsigned char);
void motors_delay();

unsigned char ADC_Conversion(unsigned char);
unsigned char ADC_Value;
unsigned char flag = 0;
unsigned char Left_white_line = 0;
unsigned char Center_white_line = 0;
unsigned char Right_white_line = 0;
unsigned long int ShaftCountLeft = 0; //to keep track of left position encoder 
unsigned long int ShaftCountRight = 0; //to keep track of right position encoder
unsigned int Degrees; //to accept angle in degrees for turning
/*********************************************/
volatile unsigned long int pulse = 0; //to keep the track of the number of pulses generated by the color sensor
volatile unsigned long int red;       // variable to store the pulse count when read_red function is called
volatile unsigned long int blue;      // variable to store the pulse count when read_blue function is called
volatile unsigned long int green;     // variable to store the pulse count when read_green function is called
int red_count=0, blue_count=0, green_count=0;
/**********************************************/


/*
. *
. * Function Name: <buzzer_pin_config>
. * Input: <Setting PORTC as outputand logic low to turnoff buzzer>
. * Output:<Configuring the output pins for buzzer beep>
. * Logic: <The configuration for the C register has been defined as 0xF7 that lowers the third pin and sets it as output pin>
. * Example Call:< buzzer_pin_config();>
. *
. */
//Function to initialize Buzzer 
void buzzer_pin_config (void)
{
 DDRC = DDRC | 0x08;         //Setting PORTC 3 as output	
 PORTC = PORTC & 0xF7;		//Setting PORTC 3 logic low to turnoff buzzer

 }

/*
. *
. * Function Name: <lcd_port_config>
. * Input: <all the LCD pin's direction set as output and all the LCD pins are set to logic 0 except PORTC 7>
. * Output:<The LCD ports are configured >
. * Logic: < The configuration for C register has been Defined as 0x08 that sets logic 0 except pin 7
. * Example Call: <lcd_port_config ();>
. *
. */
void lcd_port_config (void)
{
 DDRC = DDRC | 0xF7; //all the LCD pin's direction set as output
 PORTC = PORTC & 0x80; // all the LCD pins are set to logic 0 except PORTC 7
}

/*
. *
. * Function Name: <color_sensor_pin_config>
. * Input: <Set Port D  pin 0 as input for color sensor>
. * Output: <Internal pull-up for PORTD 0 pin>
. * Logic: <pin 0 of port D has been set as input Port given logic 0 i.e. 0xFE and has been enabled internal pull-up>
. * Example Call: <color_sensor_pin_config();>
. *
. */
void color_sensor_pin_config(void)
{
	DDRD  = DDRD | 0xFE; //set PD0 as input for color sensor output
	PORTD = PORTD | 0x01;//Enable internal pull-up for PORTD 0 pin
}

/*
. *
. * Function Name: <led_pin_config>
. * Input: <Set J register as 0xC2 configured as Input Pins for the LED >
. * Output: <Enabling the pin configurations as output pins for glowing the LED>
. * Logic: <J register has been configured as the LED pins and PIN 6,7,1 are given Logic 1 as logic 1 is output>
. * Example Call: <led_pin_config();>
. *
. */

void led_pin_config(void)
{
    DDRJ  = DDRJ | 0xC2;// set PJ1, PJ6, PJ7 as input for LED
	PORTJ = PORTJ | 0xC2; // the Pin 6, 7, 1 are given logic 1 
}


/*
. *
. * Function Name: <color_sensor_pin_interrupt_init>
. * Input: <INT0 is set to trigger with falling edge>
. * Output: <Enable Interrupt INT0 for color sensor>
. * Logic: <To interrupt the color sensor pin INT0>
. * Example Call: <color_sensor_pin_interrupt_init();>
. *
. */
void color_sensor_pin_interrupt_init(void) //Interrupt 0 enable
{
	cli(); //Clears the global interrupt
	EICRA = EICRA | 0x02; // INT0 is set to trigger with falling edge
	EIMSK = EIMSK | 0x01; // Enable Interrupt INT0 for color sensor
	sei(); // Enables the global interrupt
}

//ISR for color sensor
ISR(INT0_vect) 
{
	pulse++; //increment on receiving pulse from the color sensor
}



/*
. *
. * Function Name: < filter_red>
. * Input: <set S2 low and set S3 low>
. * Output: <to filter Red color>
. * Logic: <when S2 and S3 are low then Red is Filtered>
. * Example Call: <void filter_red(); >
. *
. */
//Filter Selection
void filter_red(void)    //Used to select red filter
{
	//Filter Select - red filter
	PORTD = PORTD & 0xBF; //set S2 low
	PORTD = PORTD & 0x7F; //set S3 low
}



/*
. *
. * Function Name: < filter_green>
. * Input: <set S2 high and set S3 high>
. * Output: <to filter green color>
. * Logic: <when S2 and S3 are high then green is Filtered>
. * Example Call: <void filter_green(); >
. *
. */
void filter_green(void)	//Used to select green filter
{
	//Filter Select - green filter
	PORTD = PORTD | 0x40; //set S2 High
	PORTD = PORTD | 0x80; //set S3 High
}


/*
. *
. * Function Name: < filter_blue>
. * Input: <set S2 low and set S3 high>
. * Output: <to filter blue color>
. * Logic: <when S2 is Low and S3 is high then blue is Filtered>
. * Example Call: <void filter_blue(); >
. *
. */
void filter_blue(void)	//Used to select blue filter
{
	//Filter Select - blue filter
	PORTD = PORTD & 0xBF; //set S2 low
	PORTD = PORTD | 0x80; //set S3 High
}



/*
. *
. * Function Name: < filter_clear>
. * Input: <set S2 high and set S3 low>
. * Output: <no color is filtered> 
. * Logic: <when S2 is high and S3 is low then no color is filtered>
. * Example Call: <void filter_clear(); >
. *
. */
void filter_clear(void)	//select no filter
{
	//Filter Select - no filter
	PORTD = PORTD | 0x40; //set S2 High
	PORTD = PORTD & 0x7F; //set S3 Low
}


/*
. *
. * Function Name: <color_sensor_scaling>
. * Input: <set S0 high and set S1 low>
. * Output: <output is 20% scaled>
. * Logic: <when color is scaled at 20% then S0 is high and S1 is low>
. * Example Call: <color_sensor_scaling(); >
. *
. */
//Color Sensing Scaling
void color_sensor_scaling()		//This function is used to select the scaled down version of the original frequency of the output generated by the color sensor, generally 20% scaling is preferable, though you can change the values as per your application by referring datasheet
{
	//Output Scaling 20% from datasheet
	//PORTD = PORTD & 0xEF;
	PORTD = PORTD | 0x10; //set S0 high
	//PORTD = PORTD & 0xDF; //set S1 low
	PORTD = PORTD | 0x20; //set S1 high
}

/*
. *
. * Function Name: <red_led()>
. * Input: <set PJ1, PJ6, PJ7 as input for LED>
. * Output: <Red Led Glows>
. * Logic: < Red color only Glows when pin 1 is given Logic 0 and rest all pins are set to logic 1>
. * Example Call: <red_led() >
. *
. */
void red_led()
{   
    PORTJ = PORTJ | 0xC2;  //set PJ1, PJ6, PJ7 as input for LED
	PORTJ = PORTJ & 0xFD;  // PJ1 given logic 0 for Red LED to glow
}

/*
. *
. * Function Name: <blue_led()>
. * Input: <set PJ1, PJ6, PJ7 as input for LED>
. * Output: <blue Led Glows>
. * Logic: < blue color only Glows when pin 6 is given Logic 0 and rest all pins are set to logic 1>
. * Example Call: <blue_led() >
. *
. */
void blue_led()
{
    PORTJ = PORTJ | 0xC2; //set PJ1, PJ6, PJ7 as input for LED
	PORTJ = PORTJ & 0xBF;  //PJ6 given logic 0 for blue LED to glow
}



/*
. *
. * Function Name: <green_led()>
. * Input: <set PJ1, PJ6, PJ7 as input for LED>
. * Output: <green Led Glows>
. * Logic: < green color only Glows when pin 7 is given Logic 0 and rest all pins are set to logic 1>
. * Example Call: <green_led() >
. *
. */
void green_led()
{
    PORTJ = PORTJ | 0xC2;  //set PJ1, PJ6, PJ7 as input for LED
	PORTJ = PORTJ & 0x7F;  //PJ7 given logic 0 for green LED to glow
}


/*
. *
. * Function Name: <Black_led()>
. * Input: <set PJ1, PJ6, PJ7 as input for LED>
. * Output: <no color, Led is disabled>
. * Logic: < No color glows i.e. LED is disabled when all pins of J register are set to logic 1>
. * Example Call: <black_led() >
. *
. */
void black_led()
{
    PORTJ = PORTJ | 0xC2;  //set PJ1, PJ6, PJ7 as input for LED
	PORTJ = PORTJ & 0xFF;  //All given logic 1 for no LED to glow

}


//ADC pin configuration
void adc_pin_config (void)
{
 DDRF = 0x00; 
 PORTF = 0x00;
 DDRK = 0x00;
 PORTK = 0x00;
}

void adc_init()
{
	ADCSRA = 0x00;
	ADCSRB = 0x00;		//MUX5 = 0
	ADMUX = 0x20;		//Vref=5V external --- ADLAR=1 --- MUX4:0 = 0000
	ACSR = 0x80;
	ADCSRA = 0x86;		//ADEN=1 --- ADIE=1 --- ADPS2:0 = 1 1 0
}

//Function For ADC Conversion
unsigned char ADC_Conversion(unsigned char Ch) 
{
	unsigned char a;
	if(Ch>7)
	{
		ADCSRB = 0x08;
	}
	Ch = Ch & 0x07;  			
	ADMUX= 0x20| Ch;	   		
	ADCSRA = ADCSRA | 0x40;		//Set start conversion bit
	while((ADCSRA&0x10)==0);	//Wait for conversion to complete
	a=ADCH;
	ADCSRA = ADCSRA|0x10; //clear ADIF (ADC Interrupt Flag) by writing 1 to it
	ADCSRB = 0x00;
	return a;
}

//Function To Print Sesor Values At Desired Row And Coloumn Location on LCD
void print_sensor(char row, char coloumn,unsigned char channel)
{
	
	ADC_Value = ADC_Conversion(channel);
	lcd_print(row, coloumn, ADC_Value, 3);

}

//Function for velocity control
void velocity (unsigned char left_motor, unsigned char right_motor)
{
	OCR5AL = (unsigned char)left_motor;
	OCR5BL = (unsigned char)right_motor;
}

/*************************************servo motor code***********************************************/
//Configure PORTB 5 pin for servo motor 1 operation
void servo1_pin_config (void)
{
 DDRB  = DDRB | 0x20;  //making PORTB 5 pin output
 PORTB = PORTB | 0x20; //setting PORTB 5 pin to logic 1
}

//Configure PORTB 6 pin for servo motor 2 operation
void servo2_pin_config (void)
{
 DDRB  = DDRB | 0x40;  //making PORTB 6 pin output
 PORTB = PORTB | 0x40; //setting PORTB 6 pin to logic 1
}

//Configure PORTB 7 pin for servo motor 3 operation
void servo3_pin_config (void)
{
 DDRB  = DDRB | 0x80;  //making PORTB 7 pin output
 PORTB = PORTB | 0x80; //setting PORTB 7 pin to logic 1
}

// Timer 5 initialized in PWM mode for velocity control
// Prescale:256
// PWM 8bit fast, TOP=0x00FF
// Timer Frequency:225.000Hz
 //TIMER1 initialization in 10 bit fast PWM mode  
//prescale:256
// WGM: 7) PWM 10bit fast, TOP=0x03FF
// actual value: 52.25Hz 

void timer1_init(void)
{
 TCCR1B = 0x00; //stop
 TCNT1H = 0xFC; //Counter high value to which OCR1xH value is to be compared with
 TCNT1L = 0x01;	//Counter low value to which OCR1xH value is to be compared with
 OCR1AH = 0x03;	//Output compare Register high value for servo 1
 OCR1AL = 0xFF;	//Output Compare Register low Value For servo 1
 OCR1BH = 0x03;	//Output compare Register high value for servo 2
 OCR1BL = 0xFF;	//Output Compare Register low Value For servo 2
 OCR1CH = 0x03;	//Output compare Register high value for servo 3
 OCR1CL = 0xFF;	//Output Compare Register low Value For servo 3
 ICR1H  = 0x03;	
 ICR1L  = 0xFF;
 TCCR1A = 0xAB; /*{COM1A1=1, COM1A0=0; COM1B1=1, COM1B0=0; COM1C1=1 COM1C0=0}
 					For Overriding normal port functionality to OCRnA outputs.
				  {WGM11=1, WGM10=1} Along With WGM12 in TCCR1B for Selecting FAST PWM Mode*/
 TCCR1C = 0x00;
 TCCR1B = 0x0C; //WGM12=1; CS12=1, CS11=0, CS10=0 (Prescaler=256)
}

void timer5_init()
{
	TCCR5B = 0x00;	//Stop
	TCNT5H = 0xFF;	//Counter higher 8-bit value to which OCR5xH value is compared with
	TCNT5L = 0x01;	//Counter lower 8-bit value to which OCR5xH value is compared with
	OCR5AH = 0x00;	//Output compare register high value for Left Motor
	OCR5AL = 0xFF;	//Output compare register low value for Left Motor
	OCR5BH = 0x00;	//Output compare register high value for Right Motor
	OCR5BL = 0xFF;	//Output compare register low value for Right Motor
	OCR5CH = 0x00;	//Output compare register high value for Motor C1
	OCR5CL = 0xFF;	//Output compare register low value for Motor C1
	TCCR5A = 0xA9;	/*{COM5A1=1, COM5A0=0; COM5B1=1, COM5B0=0; COM5C1=1 COM5C0=0}
 					  For Overriding normal port functionality to OCRnA outputs.
				  	  {WGM51=0, WGM50=1} Along With WGM52 in TCCR5B for Selecting FAST PWM 8-bit Mode*/
	
	TCCR5B = 0x0B;	//WGM12=1; CS12=0, CS11=1, CS10=1 (Prescaler=64)
}

//Function to rotate Servo 1 by a specified angle in the multiples of 1.86 degrees
void servo_1(unsigned char degrees)  
{
 float PositionPanServo = 0;
  PositionPanServo = ((float)degrees / 1.86) + 35.0;
 OCR1AH = 0x00;
 OCR1AL = (unsigned char) PositionPanServo;
}


//Function to rotate Servo 2 by a specified angle in the multiples of 1.86 degrees
void servo_2(unsigned char degrees)
{
 float PositionTiltServo = 0;
 PositionTiltServo = ((float)degrees / 1.86) + 35.0;
 OCR1BH = 0x00;
 OCR1BL = (unsigned char) PositionTiltServo;
}

//Function to rotate Servo 3 by a specified angle in the multiples of 1.86 degrees
void servo_3(unsigned char degrees)
{
 float PositionServo = 0;
 PositionServo = ((float)degrees / 1.86) + 35.0;
 OCR1CH = 0x00;
 OCR1CL = (unsigned char) PositionServo;
}

 

/******************************************servo motor code ends here **************************************/


//Function to configure ports to enable robot's motion
void motion_pin_config (void) 
{
 DDRA = DDRA | 0x0F;
 PORTA = PORTA & 0xF0;
 DDRL = DDRL | 0x18;   //Setting PL3 and PL4 pins as output for PWM generation
 PORTL = PORTL | 0x18; //PL3 and PL4 pins are for velocity control using PWM.
}

//Function to configure INT4 (PORTE 4) pin as input for the left position encoder
void left_encoder_pin_config (void)
{
 DDRE  = DDRE & 0xEF;  //Set the direction of the PORTE 4 pin as input
 PORTE = PORTE | 0x10; //Enable internal pull-up for PORTE 4 pin
}

//Function to configure INT5 (PORTE 5) pin as input for the right position encoder
void right_encoder_pin_config (void)
{
 DDRE  = DDRE & 0xDF;  //Set the direction of the PORTE 4 pin as input
 PORTE = PORTE | 0x20; //Enable internal pull-up for PORTE 4 pin
}

//Function to initialize ports
void port_init()
{
	lcd_port_config();
    color_sensor_pin_config();//color sensor pin configuration
    led_pin_config();// led pin configuration
    buzzer_pin_config();// buzzzer pin configuration

	adc_pin_config();
	motion_pin_config();
	servo1_pin_config(); //Configure PORTB 5 pin for servo motor 1 operation
    servo2_pin_config(); //Configure PORTB 6 pin for servo motor 2 operation 
    servo3_pin_config(); //Configure PORTB 7 pin for servo motor 3 operation 
	left_encoder_pin_config(); //left encoder pin config
    right_encoder_pin_config(); //right encoder pin config
}


void left_position_encoder_interrupt_init (void) //Interrupt 4 enable
{
 cli(); //Clears the global interrupt
 EICRB = EICRB | 0x02; // INT4 is set to trigger with falling edge
 EIMSK = EIMSK | 0x10; // Enable Interrupt INT4 for left position encoder
 sei();   // Enables the global interrupt 
}

void right_position_encoder_interrupt_init (void) //Interrupt 5 enable
{
 cli(); //Clears the global interrupt
 EICRB = EICRB | 0x08; // INT5 is set to trigger with falling edge
 EIMSK = EIMSK | 0x20; // Enable Interrupt INT5 for right position encoder
 sei();   // Enables the global interrupt 
}

//ISR for right position encoder
ISR(INT5_vect)  
{
 ShaftCountRight++;  //increment right shaft position count
}


//ISR for left position encoder
ISR(INT4_vect)
{
 ShaftCountLeft++;  //increment left shaft position count
}


//Function used for setting motor's direction
void motion_set (unsigned char Direction)
{
 unsigned char PortARestore = 0;

 Direction &= 0x0F; 		// removing upper nibbel for the protection
 PortARestore = PORTA; 		// reading the PORTA original status
 PortARestore &= 0xF0; 		// making lower direction nibbel to 0
 PortARestore |= Direction; // adding lower nibbel for forward command and restoring the PORTA status
 PORTA = PortARestore; 		// executing the command
}

void forward (void) // Both Wheels Move Forward
{
  motion_set (0x06); 
}

void back (void) //both wheels backward
{
  motion_set(0x09);
}

void left (void) //Left wheel backward, Right wheel forward
{
  motion_set(0x05);
}

void right (void) //Left wheel forward, Right wheel backward
{
  motion_set(0x0A);
}

void soft_left (void) //Left wheel stationary, Right wheel forward
{
 motion_set(0x04);
}

void soft_right (void) //Left wheel forward, Right wheel is stationary
{
 motion_set(0x02);
}

void soft_left_2 (void) //Left wheel backward, right wheel stationary
{
 motion_set(0x01);
}

void soft_right_2 (void) //Left wheel stationary, Right wheel backward
{
 motion_set(0x08);
}

void stop (void)  // Robot Stops
{
  motion_set(0x00); 
}

//Function used for turning robot by specified degrees
void angle_rotate(unsigned int Degrees)
{
 float ReqdShaftCount = 0;
 unsigned long int ReqdShaftCountInt = 0;

 ReqdShaftCount = (float) Degrees/ 4.090; // division by resolution to get shaft count
 ReqdShaftCountInt = (unsigned int) ReqdShaftCount;
 ShaftCountRight = 0; 
 ShaftCountLeft = 0; 

 while (1)
 {
  if((ShaftCountRight >= ReqdShaftCountInt) | (ShaftCountLeft >= ReqdShaftCountInt))
  break;
 }
 stop(); //Stop robot
}

//Function used for moving robot forward by specified distance
void linear_distance_mm(unsigned int DistanceInMM)
{
 float ReqdShaftCount = 0;
 unsigned long int ReqdShaftCountInt = 0;

 ReqdShaftCount = DistanceInMM / 5.338; // division by resolution to get shaft count
 ReqdShaftCountInt = (unsigned long int) ReqdShaftCount;
  
 ShaftCountRight = 0;
 while(1)
 {
  if(ShaftCountRight > ReqdShaftCountInt)
  {
  	break;
  }
 } 
 stop(); //Stop robot
}

void forward_mm(unsigned int DistanceInMM)
{
 forward();
 linear_distance_mm(DistanceInMM);
}

void back_mm(unsigned int DistanceInMM)
{
 back();
 linear_distance_mm(DistanceInMM);
}

void left_degrees(unsigned int Degrees) 
{
// 88 pulses for 360 degrees rotation 4.090 degrees per count
 left(); //Turn left
 angle_rotate(Degrees);
}


void right_degrees(unsigned int Degrees)
{
// 88 pulses for 360 degrees rotation 4.090 degrees per count
 right(); //Turn right
 angle_rotate(Degrees);
}


void soft_left_degrees(unsigned int Degrees)
{
 // 176 pulses for 360 degrees rotation 2.045 degrees per count
 soft_left(); //Turn soft left
 Degrees=Degrees*2;
 angle_rotate(Degrees);
}

void soft_right_degrees(unsigned int Degrees)
{
 // 176 pulses for 360 degrees rotation 2.045 degrees per count
 soft_right();  //Turn soft right
 Degrees=Degrees*2;
 angle_rotate(Degrees);
}

void soft_left_2_degrees(unsigned int Degrees)
{
 // 176 pulses for 360 degrees rotation 2.045 degrees per count
 soft_left_2(); //Turn reverse soft left
 Degrees=Degrees*2;
 angle_rotate(Degrees);
}

void soft_right_2_degrees(unsigned int Degrees)
{
 // 176 pulses for 360 degrees rotation 2.045 degrees per count
 soft_right_2();  //Turn reverse soft right
 Degrees=Degrees*2;
 angle_rotate(Degrees);
}



/*
 *
 * Function Name: < void buzzer_on(void)>
 * Output: beeps
 * Example Call: <buzzer_on();>
 *
 */
void buzzer_on (void)
{
 unsigned char port_restore = 0;
 port_restore = PINC;
 port_restore = port_restore | 0x08;
 PORTC = port_restore;
}

/*
 *
 * Function Name: < void buzzer_off(void)>
 * Output: stops beeping
 * Example Call: <buzzer_off();>
 *
 */
void buzzer_off (void)
{
 unsigned char port_restore = 0;
 port_restore = PINC;
 port_restore = port_restore & 0xF7;
 PORTC = port_restore;
}


/*
 *
 * Function Name: < void red_read(void)>
 * Input: <red filter is selected while pulse is equal to 0>
 * Output: <number of pulses are counted and count is more for red and less for green and blue >
 * logic: <count the number of pulses>
 * Example Call: <red_read();>
 *
 */

void red_read(void) // function to select red filter and display the count generated by the sensor on LCD. The count will be more if the color is red. The count will be very less if its blue or green.
{
	//Red
	filter_red(); //select red filter
	pulse=0; //reset the count to 0
	_delay_ms(100); //capture the pulses for 100 ms or 0.1 second
	red = pulse;  //store the count in variable called red
}


/*
 *
 * Function Name: < void green_read>
 * Input: <green filter is selected while pulse is equal to 0>
 * Output: <number of pulses are counted and count is more for green and less for red and blue >
 * logic: <count the number of pulses>
 * Example Call: <green_read();>
 *
 */
void green_read(void) // function to select green filter and display the count generated by the sensor on LCD. The count will be more if the color is green. The count will be very less if its blue or red.
{
	//Green
	filter_green(); //select green filter
	pulse=0; //reset the count to 0
	_delay_ms(100); //capture the pulses for 100 ms or 0.1 second
	green = pulse;  //store the count in variable called green	
}


/*
 *
 * Function Name: < void blue_read>
 * Input: <blue filter is selected while pulse is equal to 0>
 * Output: <number of pulses are counted and count is more for blue and less for red and green >
 * logic: <count the number of pulses>
 * Example Call: <blue_read();>
 *
 */
void blue_read(void) // function to select blue filter and display the count generated by the sensor on LCD. The count will be more if the color is blue. The count will be very less if its red or green.
{
	//Blue
	filter_blue(); //select blue filter
	pulse=0; //reset the count to 0
	_delay_ms(100); //capture the pulses for 100 ms or 0.1 second
	blue = pulse;  //store the count in variable called blue
	
}

/*
*
* Function Name: < void pickup()>
* Output: picks the box
* Logic: <this function will just pick up the box from pickup points >
* Example Call: <pickup();>
*
*/
void pickup()
{
unsigned char i = 0;
 for (i = 0; i<90; i++)// moving the servo motors by 90 degree
             {
              servo_1(i); // movement of  first hand servo in one direction i.e, forward
			  
              _delay_ms(250);
			  _delay_ms(250);
			  _delay_ms(250);

  
             servo_2(i); // movement of second hand servo motor in one direction i.e, forward
			 _delay_ms(250);
			 

		     break;
		
            }
}
/*
*
* Function Name: <void deposit()>
* Output: deposit the box
* Logic: <this function will deposit the boxes at deposition block>
* Example Call: <deposit();>
*
*/
void deposit()
{
unsigned char i = 0;
_delay_ms(250);
			 for (i =90; i>0; i--) // moves the servo motor by 90 degree
             {
              servo_1(i); //movement of first hand servo motor in one direction i.e, backward
              
			  break;
			  }
             for (i =170; i>0; i--) // moves the servo motor bu 170 degree
			 {
              servo_2(i); // movement of second hand servo motor in one direction i,e., backward


              break;
                             }
             
			 black_led(); //to turn off the led after depositing the box
			 _delay_ms(250);
			 _delay_ms(250);
}


/*
 *
 * Function Name: <void color_sensor()>
 * Input: <red, blue, green to read the pulses of the respective color
            red_count,blue_count, green_count to count the no of boxes of a particular color>
 * Output: <Sense the color red, green,blue or black as per the color of the box>
 * Logic: <Which color pulse is more than the other two , that color is of the box, and if the pulse of all red , blue and green are less 
			than a threshold value 2500 for red and 2000 for both green and blue then the color is black and it beeps>
 * Example Call: color_sensor();
 *
 */

void color_sensor()
{

	red_read(); //counts pulse count when red filter is selected
	        _delay_ms(200);
	        green_read(); //counts the pulse count when green filter is selected
	        _delay_ms(200);
	         blue_read(); //counts pulse count when blue filter is selected
			_delay_ms(200);


            
	 if(red <2500 && blue<2000 && green<2000) // to identify black color
	   {
	   
	  	   _delay_ms(200); 
	   _delay_ms(200); 
	   buzzer_on(); // to beep once
		_delay_ms(250);	
		_delay_ms(250);	//delay
		buzzer_off(); 
		_delay_ms(250);
		
	   }
	   else if(red>blue && red> green) // to identify red color
	   {
	   red_count++; // count the red color boxes
	     
	   	   _delay_ms(250);	
        red_led(); // glow the red color LED
		_delay_ms(250);
		
				
		
		if(red_count<=2) // if red boxes are less than or equal to two ,so pick up the box as till  now we are having one deposition box
		pickup(); // pick the box

		
	   }
	   else if(blue> red && blue> green) // to identify red color
	   {
	   blue_count++;// count blue color boxes
	   _delay_ms(250);
	   	
        blue_led(); //  glow the blue color LED
		_delay_ms(250);	
		
		if(blue_count<=4)//if red boxes are less than or equal to four ,so pick up the box as till  now we are having two deposition box
		{
			pickup(); // pick the box
			}
			

	   }
	   else if(green> blue && green>red)
	   {
	  green_count++; //count the red color boxes
	   
	   _delay_ms(250);	
         green_led();  //glow the red color LED
       	 _delay_ms(250);
		 
		 if(green_count<=4)//if red boxes are less than or equal to four,so pick up the box as till  now we are having two deposition box
		 		{
				pickup(); // pick the box
				}
				

        }
}
 
 
 /*
. *
. * Function Name: <init_devices(void)>. 
. * Output: <Calls the above declared function>
. * Logic: <initialises or calls the all function used in the program>
. * Example Call:init_devices();
. *
. */

void init_devices (void) 
{
    
 	cli(); //Clears the global interrupts
	port_init();
    color_sensor_pin_interrupt_init();  // Calls function color_sensor_pin_interrupt_init()
	adc_init();                         // Calls function adc_init();
	timer5_init();                      // Calls function timer5_init()
	timer1_init();                      // Calls function timer1_init()
	left_position_encoder_interrupt_init();  // Calls function 	left_position_encoder_interrupt_init()
    right_position_encoder_interrupt_init();  // Calls function right_position_encoder_interrupt_init()
	sei();   //Enables the global interrupts 
}
/**********************************************Main Function*********************************************/
/*
* Function Name: main
* Input: None
* Output: makes the robot work  (C code standard)
* Logic: Makes the robot navigate by using the values obtained by the different sensors and work properly
* Example Call: Called automatically by the Operating System
*
*/
int main()
{
	init_devices();// calls the functions
	lcd_set_4bit();
	lcd_init();
     int count=0; // initialises count with 0 value

     color_sensor_scaling();// 20% frequency scaling of the color


	while(1)
	{
		Left_white_line = ADC_Conversion(3);	//Getting data of Left WL Sensor
		Center_white_line = ADC_Conversion(2);	//Getting data of Center WL Sensor
		Right_white_line = ADC_Conversion(1);	//Getting data of Right WL Sensor

		flag=0;

	

	    if((Center_white_line>=0x32 && Left_white_line>=0x32) || (Center_white_line>=0x32 && Right_white_line>=0x32))// detecting nodes
		{
		     
             count++; // incrementing the counter 		
			 // moving according to  the nodes count from the start position	
            
			if(count==1) 
			{
			forward_mm(50); //moving forward by 50 mm
			}

			if(count==2) 
			{							
		    forward_mm(65); // moving forward by 65mm
			stop();			
			_delay_ms(250);
			_delay_ms(250);
			
			right_degrees(90); // moving right by 90 degrees
			
			_delay_ms(250);
			_delay_ms(250);
			stop();
			_delay_ms(250);
			
			}
			else if(count==3) 
		    {						
		    forward_mm(65); // forward by 65 mm
			stop();			
			_delay_ms(250);			
			right_degrees(90);  // moving right by 90 degrees
			stop();
			_delay_ms(200);	
			color_sensor(); // sense the color and pick up accordingly
            _delay_ms(250);
            _delay_ms(250);
			right_degrees(90);	// moving right by 90 degrees
			_delay_ms(250);
			stop();
			_delay_ms(250);

			}
			else if (count==4)
			{							
		    forward_mm(65);  //moving forward by 65 mm
			stop();			
			_delay_ms(250);
			_delay_ms(250);

			
			right_degrees(90);  // moving right by 90 degrees
			
			_delay_ms(250);
			_delay_ms(250);

			stop();
			_delay_ms(250);
			}
			else if (count==5)						
			{							
		    forward_mm(65);  //moving forward by 65 mm
			stop();			
			_delay_ms(250);
			_delay_ms(250);

			
			left_degrees(90);  // moving left by 90 degrees
			
			_delay_ms(250);
			_delay_ms(250);

			stop();
			_delay_ms(250);
			_delay_ms(250);

			}
			else if(count==6)
		    {						
		    forward_mm(65);  //moving forward by 65 mm
			stop();			
			_delay_ms(250);
			_delay_ms(250);

			_delay_ms(250);
			deposit();    // deposit
			 			
			right_degrees(90);  // moving right by 90 degrees
			stop();			
			_delay_ms(250);	
			_delay_ms(250);

			right_degrees(90);  // moving right by 90 degrees
			
			_delay_ms(250);
			_delay_ms(250);

			stop();
			_delay_ms(250);
			_delay_ms(250);

			}
			else if(count==7)
			{									
		    forward_mm(65);  //moving forward by 65 mm
			stop();			
			_delay_ms(250);
			_delay_ms(250);

			
			right_degrees(90);  // moving right by 90 degrees
			
			_delay_ms(250);
			_delay_ms(250);

			stop();
			_delay_ms(250);
			_delay_ms(250);
			

			}
			else if(count==8)
			{
			 forward_mm(70);  //moving forward by 70 mm
			stop();			
			_delay_ms(250);
			_delay_ms(250);
			
			left_degrees(90);  // moving left by 90 degrees
			
			_delay_ms(250);
			_delay_ms(250);

			stop();
			_delay_ms(250);
			_delay_ms(250);
			}
			else if(count==9)
			{
			forward_mm(50);  //moving forward by 50 mm
			}
			else if(count==10)
			{
			forward_mm(50);  //moving forward by 50 mm
			}
			else if (count==11)
			{
			forward_mm(65);  //moving forward by 65 mm
			stop();			
			_delay_ms(250);
			_delay_ms(250);
			right_degrees(90);  // moving right by 90 degrees
			_delay_ms(250); 
	        color_sensor();   // sense the color and pick up accordingly
			_delay_ms(250);
			right_degrees(90);  // moving right by 90 degrees
			_delay_ms(250);
			
			_delay_ms(250);
			stop();
			_delay_ms(250);
			_delay_ms(250);
			}
			else if(count==12)
			{
			forward_mm(50);  //moving forward by 50 mm
			}
			else if(count==13)
			{
			forward_mm(50);  //moving forward by 50 mm
			}
			else if(count==14)
			{
			forward_mm(50); //moving forward by 50 mm
			}
			else if (count==15)
			{
			forward_mm(65);  //moving forward by 65 mm
			stop();			
			_delay_ms(250);
			_delay_ms(250);
			left_degrees(90);  // moving left by 90 degrees
			_delay_ms(250); 
			color_sensor();	   	// sense the color and pick up accordingly
		    _delay_ms(250);
			right_degrees(90);  // moving right by 90 degrees
			_delay_ms(250);
			_delay_ms(250);			
			
			stop();
			_delay_ms(250);
			_delay_ms(250);
			}
			else if(count==16)
			{
			forward_mm(50);  //moving forward by 50 mm
			}
            else if(count==17)
		    {						
		    forward_mm(65);  //moving forward by 65 mm
			stop();			
			_delay_ms(250);
			
			
			left_degrees(90);  // moving left by 90 degrees
			stop();
			_delay_ms(200);	
 			color_sensor(); // sense the color and pick up accordingly
            _delay_ms(250);
            _delay_ms(250);



			right_degrees(90);  // moving right by 90 degrees
			_delay_ms(250);
			
			_delay_ms(250);
			stop();
			_delay_ms(250);
			_delay_ms(250);
			}
			else if(count==18)
			{
															
		    forward_mm(65); //moving forward by 65 mm
			stop();			
			_delay_ms(250);
			_delay_ms(250);

			
			right_degrees(90);   // moving right by 90 degrees
			
			_delay_ms(250);
			_delay_ms(250);

			stop();
			_delay_ms(250);
			_delay_ms(250);
			
			}
			else if(count==19)
			{
			forward_mm(50);  //moving forward by 50 mm
			}
			else if(count==20)
			{
															
		    forward_mm(65);  //moving forward by 65 mm
			stop();			
			_delay_ms(250);
			_delay_ms(250);

			
			right_degrees(90);  // moving right by 90 degrees
			
			_delay_ms(250);
			_delay_ms(250);

			stop();
			_delay_ms(250);
			_delay_ms(250);
			

			}
			else if(count==21)
			{						
		    forward_mm(65);  //moving forward by 65 mm
			stop();			
			_delay_ms(250);
			_delay_ms(250);

			_delay_ms(250);
			deposit();		// deposit the box	
			right_degrees(90);  // moving right by 90 degrees
			_delay_ms(250);
			_delay_ms(250);
			stop();
			
			_delay_ms(250);	
			_delay_ms(250);

			right_degrees(90);  // moving right by 90 degrees
			
			_delay_ms(250);
			_delay_ms(250);

			stop();
			_delay_ms(250);
			_delay_ms(250);

			}
			else if(count==22)
			{
															
		    forward_mm(65);  //moving forward by 65 mm
			stop();			
			_delay_ms(250);
			_delay_ms(250);

			
			right_degrees(90);  // moving right by 90 degrees
			
			_delay_ms(250);
			_delay_ms(250);

			stop();
			_delay_ms(250);
			_delay_ms(250);
			

			}
			else if(count==23)
			{
															
		    forward_mm(65);
			stop();			
			_delay_ms(250);
			_delay_ms(250);

			
			right_degrees(90);  // moving right by 90 degrees
			  
			_delay_ms(250);
			_delay_ms(250);

			stop();
			_delay_ms(250);
			_delay_ms(250);
			

			}
			else if(count==24)
			{
			forward_mm(50);  //moving forward by 50 mm
			}
			else if(count==25)
			
			{
			forward_mm(65);  //moving forward by 65 mm
			stop();			
			_delay_ms(250);
			
			
			left_degrees(90);  // moving left by 90 degrees
			stop(); 
			_delay_ms(200);	
	     	color_sensor(); // sense the color and pick up accordingly
           _delay_ms(250);
            _delay_ms(250);
 
			right_degrees(90);  // moving right by 90 degrees
			_delay_ms(250);
			
			_delay_ms(250);
			stop();
			_delay_ms(250);
			_delay_ms(250);
			}
			else if(count==26)
			{
			forward_mm(50);  //moving forward by 50 mm
			}
			else if(count==27)
			{
															
		    forward_mm(65);  //moving forward by 65 mm
			stop();			
			_delay_ms(250);
			_delay_ms(250);

			
			right_degrees(90);  // moving right by 90 degrees
			
			_delay_ms(250);
			_delay_ms(250);

			stop();
			_delay_ms(250);
			_delay_ms(250);
			

			}
			else if(count==28)
			{
															
		    forward_mm(65);  //moving forward by 65 mm
			stop();			
			_delay_ms(250);
			_delay_ms(250);

			
			right_degrees(90);  // moving right by 90 degrees
			
			_delay_ms(250);
			_delay_ms(250);

			stop();
			_delay_ms(250);
			_delay_ms(250);
			

			}	
			else if(count==29)
			{						
		    forward_mm(65);  //moving forward by 65 mm
			stop();			
			_delay_ms(250);
			_delay_ms(250);

			_delay_ms(250);
			 deposit();  // deposit the box


			 
			right_degrees(90);  // moving right by 90 degrees
			_delay_ms(250);
			_delay_ms(250);
			stop();
			_delay_ms(250);

			_delay_ms(250);	
			

			right_degrees(90);  // moving right by 90 degrees
			
			_delay_ms(250);
			_delay_ms(250);

			stop();
			_delay_ms(250);
			_delay_ms(250);				



	     	}
	    	else if(count==30)
	      	{
															
		    forward_mm(65);  //moving forward by 65 mm
			stop();			
			_delay_ms(250);
			_delay_ms(250);

			
			left_degrees(90);  // moving left by 90 degrees
			
			_delay_ms(250);
			_delay_ms(250);

			stop();
			_delay_ms(250);
			_delay_ms(250);
			

			}
			else if(count==31)
		{
															
		    forward_mm(65);  //moving forward by 65 mm
			stop();			
			_delay_ms(250);
			_delay_ms(250);

			
			left_degrees(90);  // moving left by 90 degrees
			
			_delay_ms(250);
			_delay_ms(250);

			stop();
			_delay_ms(250);
			_delay_ms(250);
			

			}
			else if(count==32)
			{
			forward_mm(65);  //moving forward by 65 mm
			stop();			
			_delay_ms(250);
			_delay_ms(250);
			right_degrees(90);  // moving right by 90 degrees
			_delay_ms(250); 
	       _delay_ms(250); 
	          color_sensor();	// sense the color and pick up accordingly
		   _delay_ms(250);
	   		right_degrees(90);  // moving right by 90 degrees
			
			_delay_ms(250);
			_delay_ms(250);
			stop();
			_delay_ms(250);
			_delay_ms(250);
			}
			else if(count==33)
			{
			forward_mm(50);  //moving forward by 50 mm
			}
			else if(count==34)
			{
			forward_mm(50);   //moving forward by 50 mm
			}
			else if(count==35)
			{
			forward_mm(65);   //moving forward by 65 mm
			stop();			
			_delay_ms(250);
			
			
			left_degrees(90);  // moving left by 90 degrees
			stop();
			_delay_ms(200);	
			color_sensor(); // sense the color and pick up accordingly
            _delay_ms(250);
            _delay_ms(250);

			left_degrees(90);  // moving left by 90 degrees
			_delay_ms(250);
			
			_delay_ms(250);
			stop();
			_delay_ms(250);
			_delay_ms(250);
		 	}
            else if(count==36)
	    	{
		    forward_mm(50);  //moving forward by 50 mm
		    }
		    else if(count==37)
		    {
															
		    forward_mm(65);    //moving forward by 65 mm
			stop();			
			_delay_ms(250);
			_delay_ms(250);

			
			left_degrees(90);  // moving left by 90 degrees
			
			_delay_ms(250);
			_delay_ms(250);

			stop();
			_delay_ms(250);
			_delay_ms(250);
			

			}
			else if(count==38)
			{
			forward_mm(50);   //moving forward by 50 mm
			}
			
			
			else if(count==39)
			{						
		    forward_mm(65);   //moving forward by 65 mm
			stop();			
			_delay_ms(250);
			_delay_ms(250);

			_delay_ms(250);
			 deposit();		  // deposit the box	
			right_degrees(90);  // moving right by 90 degrees
			_delay_ms(250);
			_delay_ms(250);
			stop();
			_delay_ms(250);

			_delay_ms(250);	
	
			right_degrees(90);  // moving right by 90 degrees
			
			_delay_ms(250);
			_delay_ms(250);

			stop();
			_delay_ms(250);
			_delay_ms(250);				



	     	}
	    	else if(count==40)
	    	{
		    forward_mm(50);   //moving forward by 50 mm
	     	}
	    	else if(count==41)
	    	{
															
		    forward_mm(65);   //moving forward by 65 mm
			stop();			
			_delay_ms(250);
			_delay_ms(250);

			
			right_degrees(90);  // moving right by 90 degrees
			
			_delay_ms(250);
			_delay_ms(250);

			stop();
			_delay_ms(250);
			_delay_ms(250);
			

			}
			else if(count==42)
			{
			forward_mm(50);   //moving forward by 50 mm
			}
			else if(count==43)
			{
			forward_mm(50);   //moving forward by 50 mm
			}
			else if(count==44)
			{
			forward_mm(65);   //moving forward by 65 mm
			stop();			
			_delay_ms(250);
			
			
			left_degrees(90);  // moving left by 90 degrees
			stop();
			_delay_ms(200);	
		    color_sensor();  // sense the color and pick up

            _delay_ms(250);
            _delay_ms(250);
 
			left_degrees(90);  // moving left by 90 degrees
			_delay_ms(250);
			
			_delay_ms(250);
			stop();
			_delay_ms(250);
			_delay_ms(250);
			}
			else if(count==45)
		    {
															
		    forward_mm(50);	  //moving forward by 50 mm

			}
			else if(count==46)
			{
			forward_mm(50);  //moving forward by 50 mm
			}
			else if(count==47)
			{
			forward_mm(50);  //moving forward by 50 mm
			}
			else if(count==48)
			{
			forward_mm(50);  //moving forward by 50 mm
			}
			else if(count==49)
			{
			forward_mm(50);  //moving forward by 50 mm
			}
			else if(count==50)
			{
			forward_mm(50);  //moving forward by 50 mm
			}
            else if(count==51)
		    {
															
		    forward_mm(65);  //moving forward by 65 mm
			stop();			
			_delay_ms(250);
			_delay_ms(250);

			
			left_degrees(90);  // moving left by 90 degrees
			
			_delay_ms(250);
			_delay_ms(250);

			stop();
			_delay_ms(250);
			_delay_ms(250);
			

			}
			else if(count==52)
			{
			forward_mm(50);  //moving forward by 50 mm
			}


            else if(count==53)
			{
															
		    forward_mm(65);  //moving forward by 65 mm
			stop();			
			_delay_ms(250);
			_delay_ms(250);

			
			left_degrees(90);  // moving left by 90 degrees
			
			_delay_ms(250);
			_delay_ms(250);

			stop();
			_delay_ms(250);
			_delay_ms(250);
			

			}
			
            else if(count==54)
			{						
		    forward_mm(65);  //moving forward by 65 mm
			stop();			
			_delay_ms(250);
			_delay_ms(250);

			_delay_ms(250);
			 deposit(); // deposit the box
			
			right_degrees(90);  // moving right by 90 degrees
			_delay_ms(250);
			_delay_ms(250);
			stop();
			_delay_ms(250);

				
			_delay_ms(250);

				
			buzzer_on(); // buzz continuosly
	    	_delay_ms(250);	
		   _delay_ms(250);	
		   _delay_ms(250);
		   _delay_ms(1000);
	
		   _delay_ms(250);
		   stop();
	       velocity(0,0);			



		}

			
				

		}



        else if(Center_white_line>0x08) //moves on black line if center white line sensor is on black line
		{
			flag=1;
			forward(); // moves forward
			velocity(255,250); // velocity of left wheel is 255 and right wheel is 250 		
		}

		else if(Left_white_line>0x08) // moves on black line if left white line sensor is on black line
		{
			flag=1; 
			soft_left_degrees(8); // turn  soft left by 8 degrees so that center white line sensor is on black line 
            _delay_ms(100);	
			forward(); // moves forward
			velocity(255,250); // velocity of left wheel is 255 and right wheel is 250 
		}

		else if(Right_white_line>0x08) // moves on black line if right white line sensor is on black line
		{
			flag=1;
			soft_right_degrees(8); //turn  soft right by 8 degrees so that center white line sensor is on black line 
			_delay_ms(100);	            
			forward(); // moves forward
			velocity(255,250); // velocity of left wheel is 255 and right wheel is 250 
		}
		
		
	else if(Center_white_line<=0x08 && Left_white_line<=0x08 && Right_white_line<=0x08)  // all three sensors are on white
	{
    
	stop();
	soft_right_degrees(5);// turn  soft right by 5 degrees
	if(Center_white_line>0x08 || Left_white_line>0x08 || Right_white_line>0x08) // any of the three read black
	{
	
		break;
		}	
	else if(Center_white_line<=0x08 && Left_white_line<=0x08 && Right_white_line<=0x08) //all three sensors read white
	{
	
	stop();
	soft_left_degrees(7.5);// turn  soft left by 7.5 degrees
	if(Center_white_line>0x08 || Left_white_line>0x08 || Right_white_line>0x08) // any of the three read black
	{
	
		break;	
		}


	}
	}
	
}
}

// We are still Working on this code to make it even Better
// **********************************************END******************************************************************
